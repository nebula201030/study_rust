/*
변수와 가변성
Rust의 기본 변수는 불변성 입니다. 이것은 Rust가 제공하는 안전성과 손시운 동시성이라는 
장점을 취할 수 있도록 코드를 작성하게끔 강제하는 요소중 하나입니다. 
하지만 우리는 아직도 가변 변수를 사용하고 싶어합니다. 
하지만 어떻게 그리고 왜 Rust에서 불변성을 애호해주길 권장하는지 알아버면
그런 생각을 포기할 수 있을지도 모르겠습니다.

변수가 불변성인 경우, 일단 값이 이름에 bound 되면 해당 값을 변경 할 수 없습니다.
시험삼아 아래처럼 코드를 생성해 보았습니다
*/
fn main(){
    let  x = 5;
    println!("the value of x is: {}",x);
    x = 6;
    println!("the value of x is: {}",x);
}

/*
cargo build 이후 cargo run을 실행시켜 봅시다.
프로그램에 에러가 있음을 확인하실 수 있습니다.
에러가 나타내는 것은 불변성 변수에 재할당 되었고 원인은 우리가
불변성 변수 x에 두번째로 값을 할당하였기 때문입니다.

우리가 이전에 불변성으로 선언한 것의 값을 변경하고자 하는 시도를 하면
컴파일 타임의 에러를 억데 되고 이로 인하여 벌그가 발생할 수 있기 때문에 중요합니다.
만약 우리 코드의 일부는 값이 변경되지 않는다는 것을 가정하는데 다른 코드는 이와 
다르게 값을 변경한다면 전자의 해당하는 코드는 우리가 의도한 대로 수행되지 않을 수 
있습니다. 특히 후자에 대당되는 코드는 항상 그렇지 않고 가끔 값을 
변경하는 겨우 나중에 버그의 원인을 추적하기가 매우 어렵습니다.

Rust에서는 컴파일러가 변경되지 않은 값에 대한 보증을 해주고, 실제로 이는 바뀌지 않습니다.
이것이 의미하는 바는 당신의 코드를 작성하거나 분석할 시에
변수의 값이 어떨게 변경되는지 추적할 필요가 없기 때문에 코드를 더 합리적으로 만들어 줍니다.

하지만 가변성은 매우 유용하게 사용될 수 있습니다. 변수는 기본적으로 불변성이지만
우리는 변수며의 접두어로 mut을 추가하는 것을 통해서 가변성으로 변수를 선언 할 수 있습니다.
이 변수의 값이 변경을 허용하는 것에 추가로 향후 코드를 보는 사람에게 코드의
다른 부분에서 해당 변수의 값을 변경할 것이라는 의도를 주지시킵니다
*/
fn main(){
    let mut x = 5;
    println!("the value of x is {}", x);
    x = 6;
    println!("the value of x is {}",x);
}
/*
cargo build 이후 cargo run을 실행시키면 다음 처럼 답을 얻습니다

the value of x is 5
the value of x is 6

mut 을 사용하여 x에 bind된 값을 5에서 6으로 변경할 수 있습니다.
불변성 변수만을 사용하는 것보다 가변성 변수를 사용하여 보다 쉽게 구현할 수 있을
경우 가변성 변수를 만들어 사용할 수도 있습니다.

이런 의사 결정에 있어서 버그를 예방하는 것 외에도 고려햐여 헐 요소들이 있습니다.
예를 들어 대규모 데이터 구조체를 다룰는 경우 가변한 인스턴스를 사용하는 것이 새로운
인스턴스를 할당하고 반환하는 것보다 빠를 수 있습니다.
데이터 규모가 작을수록 새 인스턴스를 생성하고 함수적 프로그래밍 스타일로 작성하는 것이
더 합리적입니다 물론 약간의 성능 하락을 통해서 가독 성을 활보할 수 있습니다 하지만 
이것은 엄청난 큰 가치가 있는 선택입니다.
*/
